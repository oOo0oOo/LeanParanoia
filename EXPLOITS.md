# Exploit Test Files

## Attributes
- **AxiomCSimp.lean** - CSimp theorem proven using custom axiom to bypass verification
- **UnsafeCSimp.lean** - CSimp theorem with unsafe implementation target

## Axioms
- **False.lean** - Custom axiom asserting False to prove anything
- **ForgeStd.lean** - Forged axiom in Std namespace to appear legitimate
- **MacroExpansion.lean** - Axiom injected via macro expansion
- **Magic.lean** - Axiom asserting all propositions are true
- **RunCmd.lean** - Axiom proven using run_cmd macro
- **RunTac.lean** - Axiom proven using run_tac macro

## Constructors
- **Manual.lean** - Manually crafted inductive constructors bypassing kernel generation

## DebugOptions
- **ByAsSorry.lean** - Debug option making 'by' tactics elaborate to sorry
- **ProofAsSorry.lean** - Debug option treating proof terms as sorry
- **SkipKernelTC.lean** - Debug option skipping kernel type checking
- **TerminalTacticsAsSorry.lean** - Debug option making terminal tactics elaborate to sorry
- **UnsafeReducibility.lean** - Debug option allowing unsafe reducibility

## Extern
- **BuiltinInitAttr.lean** - Builtin initialization hook to execute arbitrary code
- **CoreMaskExtern.lean** - Extern attribute in Lean namespace to appear legitimate
- **Export.lean** - Export attribute exposing internals to C ABI
- **Extern.lean** - Extern attribute linking to unverified C code
- **ImplementedBy.lean** - Implementation bridge replacing verified code with unverified
- **InitAttr.lean** - Initialization hook executing arbitrary IO
- **PrivateExtern.lean** - Private extern to bypass name-based filtering
- **PrivateImplementedBy.lean** - Private implemented_by to bypass detection
- **TransitiveChain.lean** - Multi-hop implemented_by chain ending in extern

## KernelReject
- **NonPositive.lean** - Non-positive inductive type rejected by kernel
- **UnsafeCast.lean** - Unsafe type cast rejected by kernel

## Metavariables
- **FailedSearch.lean** - Failed tactic search leaving unresolved metavariables
- **Timeout.lean** - Tactic timeout leaving unresolved metavariables

## NativeDecide
- **Axiom.lean** - Native computation axiom bypassing proof verification
- **Leak.lean** - Native decide leaking false proof via compiler trust

## Opaque
- **Sorry.lean** - Sorry hidden behind opaque constant

## Sorry
- **Admit.lean** - Admitted proof using admit tactic
- **Direct.lean** - Direct sorry in proof term
- **Intermediate.lean** - Sorry in intermediate lemma
- **Underscore.lean** - Underscore hole elaborating to sorry

## SourceCheck
- **LocalInstance.lean** - Local instance redefining typeclass to change behavior
- **LocalInstanceArithmetic.lean** - Local instance redefining Add to prove 1+1=3
- **LocalMacroRules.lean** - Local macro_rules changing elaboration of syntax
- **LocalNotation.lean** - Local notation redefining custom operators
- **NotationRedefinition.lean** - Local notation redefining built-in notation (True)
- **ScopedNotation.lean** - Scoped notation changing meaning within sections

## Transitive
- **BadLib.lean** - External dependency with hidden unsafe code and axioms
- **DeepAxiom_L0.lean** - Custom axiom at dependency level 0
- **DeepAxiom_L1.lean** - Theorem using custom axiom from L0
- **DeepSorry_L0.lean** - Sorry at dependency level 0
- **DeepSorry_L1.lean** - Theorem using sorry from L0 (1 level deep)
- **DeepSorry_L2.lean** - Theorem using sorry from L1 (2 levels deep)
- **Level0_Clean.lean** - Clean dependency with no exploits
- **Level1_UsesClean.lean** - Valid dependency using clean L0
- **Level2_UsesBoth.lean** - Valid dependency using clean L0 and L1
- **UsesBadLib.lean** - Theorem depending on malicious external library

## Typeclass
- **MaliciousInstance.lean** - Malicious typeclass instance changing semantics

## Unsafe
- **UnsafeDef.lean** - Unsafe definition bypassing kernel verification