"""
Tests for source-level pattern detection.

These exploits modify elaboration/parsing behavior in ways that the kernel
cannot detect, since they only affect how source code is interpreted.
"""

import pytest


@pytest.mark.exploit
def test_local_instance_rejected(verifier):
    """Local instance changes typeclass resolution"""
    result = verifier.verify_theorem(
        "LeanTestProject.SourceCheck.LocalInstance", "exploit_theorem"
    )

    assert not result.success
    assert "SourceCheck" in result.failed_tests


@pytest.mark.exploit
def test_local_notation_rejected(verifier):
    """Local notation changes operator meaning"""
    result = verifier.verify_theorem(
        "LeanTestProject.SourceCheck.LocalNotation", "exploit_theorem"
    )

    assert not result.success
    assert "SourceCheck" in result.failed_tests


@pytest.mark.exploit
def test_scoped_notation_rejected(verifier):
    """Scoped notation changes meaning within a scope"""
    result = verifier.verify_theorem(
        "LeanTestProject.SourceCheck.ScopedNotation", "exploit_theorem"
    )

    assert not result.success
    assert "SourceCheck" in result.failed_tests


@pytest.mark.exploit
def test_local_macro_rules_rejected(verifier):
    """Local macro_rules changes elaboration behavior"""
    result = verifier.verify_theorem(
        "LeanTestProject.SourceCheck.LocalMacroRules", "exploit_theorem"
    )

    assert not result.success
    # Caught by both SourceCheck (local macro_rules) AND AxiomWhitelist (hidden_axiom)
    assert "SourceCheck" in result.failed_tests
    assert "AxiomWhitelist" in result.failed_tests


@pytest.mark.exploit
def test_notation_redefinition_with_axiom(verifier):
    """Local notation redefining True, also uses axiom for False"""
    result = verifier.verify_theorem(
        "LeanTestProject.SourceCheck.NotationRedefinition",
        "exploit_theorem",
    )

    assert not result.success
    # Caught by both axiom check AND source check
    assert "AxiomWhitelist" in result.failed_tests
    assert "SourceCheck" in result.failed_tests


@pytest.mark.exploit
def test_local_instance_arithmetic(verifier):
    """Local instance redefining Add to prove 1+1=3"""
    result = verifier.verify_theorem(
        "LeanTestProject.SourceCheck.LocalInstanceArithmetic",
        "exploit_theorem",
    )

    assert not result.success
    assert "SourceCheck" in result.failed_tests


@pytest.mark.exploit
def test_source_check_can_be_disabled(verifier):
    """Test that source check can be disabled via configuration."""
    result = verifier.verify_theorem(
        "LeanTestProject.SourceCheck.NotationAxiom",
        "exploit_theorem",
        check_source=False,
    )

    # Should pass when source check is disabled
    # (though statement is mathematically wrong, kernel accepts it)
    assert result.success
